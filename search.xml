<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何利用GitHub作为图床</title>
    <url>/2022/03/20/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8GitHub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载PicGo</h2><p>进入<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo的下载地址</a>，根据系统选择版本。因为我的点好是 win11，因此选择的软件版本是 PicGo-Setup-2.3.0-x64.exe。下载完成后，双击软件按照默认设置安装。</p>
<h2 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h2><p>创建后，在我的GitHub页面中，就有一个 myImage 的仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/xiaorangood/myImage.git</span><br><span class="line">git@github.com:xiaorangood/myImage.git</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h2><p>点击“头像”-&gt;”setting” -&gt; “Developer settings” -&gt; “Personal access tokens” -&gt; “Generate New token”。</p>
<img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/Snipaste_2022-03-20_20-43-09.png" style="zoom:70%"/>

<p>设置token的名字、有效期；并勾选“repo”，最后下拉到最下方，点击“Generate token”按钮。</p>
<img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/Snipaste_2022-03-20_20-43-30.png" style="zoom:75%"/>


<h2 id="配置picgo"><a href="#配置picgo" class="headerlink" title="配置picgo"></a>配置picgo</h2><p>打开picgo软件，在左边的栏目中点击“图床设置” -&gt; “GitHub图床”。按照下面的说明设置</p>
<ul>
<li>设定仓库名：按照“用户名&#x2F;图床仓库名”的格式填写</li>
<li>设定分支名：“master”</li>
<li>设定Token：粘贴之前生成的Token</li>
<li>指定存储路径：填写想要储存的路径，如“images&#x2F;”，这样就会在仓库下创建一个名为 images 的文件夹，图片将会储存在此文件夹中。</li>
<li>设定自定义域名：它的的作用是，在图片上传后，PicGo会按照<code>自定义域名+上传的图片名</code>的方式生成访问链接，放到粘贴板上，因为我们要使用jsDelivr加速访问，所以可以设置为 <a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D%E3%80%82jsDelivr%E7%9A%84%E5%8F%82%E8%80%83%E6%A0%BC%E5%BC%8F%EF%BC%9Ahttps://cdn.jsdelivr.net/gh/xiaorangood/myImage%E3%80%82">https://cdn.jsdelivr.net/gh/用户名/图床仓库名。jsDelivr的参考格式：https://cdn.jsdelivr.net/gh/xiaorangood/myImage。</a></li>
</ul>
<p>上述的内容填写完成后，点击“确认”按钮，再设置<strong>GitHub图床为默认图床</strong>。<br><img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/20220320212009.png" style="zoom:85%"/></p>
<h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><p>点击左侧栏目里的上传区后，将需要上传的图片拖入上传区即可。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>图床</tag>
        <tag>Picgo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的Next主题配置</title>
    <url>/2022/03/26/hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="选择仓库"><a href="#选择仓库" class="headerlink" title="选择仓库"></a>选择仓库</h2><p>在设置主题时候，无意间发现Next是有两个库，名字很相像，名字与地址分别是：</p>
<ul>
<li><a href="https://github.com/theme-next/hexo-theme-next">theme-next&#x2F;hexo-theme-next</a></li>
<li><a href="https://github.com/next-theme/hexo-theme-next">next-theme&#x2F;hexo-theme-next</a></li>
</ul>
<p>next-theme的主题，是从v8.0.0开始，theme-next在写下这段文字时，版本为v7.8.0。由于默认情况下，实测V7版本在IOS浏览器中会出现主页空白的现象。这个现象需要将 motion 置 false 才可以消除。因此选择了V8以及以后的版本。</p>
<span id="more"></span>

<h2 id="fork主题并使用"><a href="#fork主题并使用" class="headerlink" title="fork主题并使用"></a>fork主题并使用</h2><p>由于在使用中会将主题进行修改，并希望保存配置，因此需要在gitHub页面将工程fork到自己的gitHub账户中。然后使用命令将Next主题仓库设置为站点source分支的子模块，放在 themes 目录下,：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add git@github.com:xiaorangood/hexo-theme-next.git themes/next</span><br><span class="line">git commit -m <span class="string">&quot;添加Next主题为子模块&quot;</span> &amp;&amp; git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>然后需改站点的 _config.yml 中主题设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"><span class="comment">#theme: landscape</span></span><br></pre></td></tr></table></figure>
<p>使用 hexo 命令重新生成网站并启动服务器，通过各终端查看效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>



<h2 id="设置主题样式"><a href="#设置主题样式" class="headerlink" title="设置主题样式"></a>设置主题样式</h2><p>Next主题默认有4种样式，其中 Pisces 和 Gemini 暂时看不出区别，先选择了 Gemini 。打开主题的 _config.yml 文件，设置为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h2 id="设置页脚建站时间"><a href="#设置页脚建站时间" class="headerlink" title="设置页脚建站时间"></a>设置页脚建站时间</h2><p>Next主题在没有设置建站时间情况下，只会显示当前时间；在 themes&#x2F;next&#x2F;_config.yml 文件中搜索 since，设置起始时间为2018年。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the year when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure>

<h2 id="设置TOC目录的样式"><a href="#设置TOC目录的样式" class="headerlink" title="设置TOC目录的样式"></a>设置TOC目录的样式</h2><p>在 themes&#x2F;next&#x2F;_config.yml 文件中搜索 toc；设置TOC目录不自动编码且不折叠：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="设置站点主页和归档页面"><a href="#设置站点主页和归档页面" class="headerlink" title="设置站点主页和归档页面"></a>设置站点主页和归档页面</h2><p>在 themes&#x2F;next&#x2F;_config.yml 文件中搜索 menu；将 home 和 archives 前的注释去除。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure>

<h2 id="页面显示当前浏览进度"><a href="#页面显示当前浏览进度" class="headerlink" title="页面显示当前浏览进度"></a>页面显示当前浏览进度</h2><p>在 themes&#x2F;next&#x2F;_config.yml 文件中搜索 scrollpercent；将false数值改为 true。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="设置代码块"><a href="#设置代码块" class="headerlink" title="设置代码块"></a>设置代码块</h2><p>在 themes&#x2F;next&#x2F;_config.yml 文件中搜索 copy_button，将复制按钮使能；查看 theme 下的 light 字段，将 light 字段的 default 修改为 monokai。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># light: default</span></span><br><span class="line">    <span class="comment"># light: rainbow</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">monokai</span></span><br><span class="line">    <span class="comment"># light: purebasic</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">stackoverflow-dark</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="string">style</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>静态博客</tag>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>在Windows下利用Hexo搭建个人博客</title>
    <url>/2022/03/20/%E5%9C%A8Windows%E4%B8%8B%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="本地创建个人博客"><a href="#本地创建个人博客" class="headerlink" title="本地创建个人博客"></a>本地创建个人博客</h2><h3 id="安装-git-工具"><a href="#安装-git-工具" class="headerlink" title="安装 git 工具"></a>安装 git 工具</h3><p>从<a href="https://git-scm.com/downloads">git官网</a>下载windows下的软件，本文按照时的软件版本为 2.35.1。</p>
<p>安装软件时，使用默认设置一直点击 Next 按钮，一直到下图的页面勾选两个选项；然后点击 Install 安装 git 软件。<br><img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/Snipaste_2022-03-20_16-10-29.png" style="zoom:90%;" /></p>
<p>勾选“Enable experimental support for pseudo consoles”选项是为了在 git bash 中启动 Hexo 服务后，可以通过 Ctrl + c 停止 Hexo 服务器的运行。</p>
<span id="more"></span>

<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>Hexo是基于Node.js的，因此在安装Hexo前，需要安装该软件。</p>
<p>从 <a href="https://nodejs.org/zh-cn/">Node.js官网</a>下载软件，当前版本号是 17.7.2。</p>
<p>下载软件后，按照默认设置安装即可。</p>
<h3 id="安装-Hexo-软件"><a href="#安装-Hexo-软件" class="headerlink" title="安装 Hexo 软件"></a>安装 Hexo 软件</h3><p>执行以下几个命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将npm镜像修改为淘宝镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry <span class="string">&quot;https://registry.npm.taobao.org&quot;</span></span><br><span class="line"><span class="comment"># 使用npm安装 Hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment"># 在当前目录下初始化一个博客目录，并进入该目录</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 在博客目录使用命令启动Hexo服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>浏览器后，输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可打开博客网页。<br>如果希望在其他端口打开网页，可以使用 Hexo 命令指定端口。例如指定端口为5000。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure>

<h3 id="创建Hexo文件"><a href="#创建Hexo文件" class="headerlink" title="创建Hexo文件"></a>创建Hexo文件</h3><p>执行以下命令后，Hexo会在 source_posts 目录下创建以文章名命名的markdown文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo n <span class="string">&quot;文章名&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后执行命令生成html文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>最后使用命令运行 Hexo 服务器即可看到新内容</p>
<h2 id="部署博客到Git-Pages"><a href="#部署博客到Git-Pages" class="headerlink" title="部署博客到Git Pages"></a>部署博客到Git Pages</h2><h3 id="创建博客仓库"><a href="#创建博客仓库" class="headerlink" title="创建博客仓库"></a>创建博客仓库</h3><p>在github页面中，创建新仓库，仓库名字为 <strong>xiaorangood.github.io</strong> 。</p>
<h3 id="安装自动部署工具并设置"><a href="#安装自动部署工具并设置" class="headerlink" title="安装自动部署工具并设置"></a>安装自动部署工具并设置</h3><p>执行以下命令安装部署工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>设置站点的_config.yml 配置文件内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xiaorangood/xiaorangood.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h3 id="测试网络连接"><a href="#测试网络连接" class="headerlink" title="测试网络连接"></a>测试网络连接</h3><p>通过命令生成 ssh 密钥:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>在获得密钥后，添加到github的个人设置页面中添加密钥：</p>
<img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/Snipaste_2022-03-20_17-38-44.png" style="zoom:75%;" />

<p>添加密钥后，通过命令验证是否连接成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi xiaorangood! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>
<p>如果出现超时的现象，通过命令设置 git 的代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">&#x27;http://127.0.0.1:10809&#x27;</span></span><br><span class="line">git config --global https.proxy <span class="string">&#x27;http://127.0.0.1:10809&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="部署个人博客网页"><a href="#部署个人博客网页" class="headerlink" title="部署个人博客网页"></a>部署个人博客网页</h3><p>在blog的目录下执行命令部署个人博客：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h2 id="使用source分支来保存博客源文件"><a href="#使用source分支来保存博客源文件" class="headerlink" title="使用source分支来保存博客源文件"></a>使用source分支来保存博客源文件</h2><h3 id="在-github-上创建新分支"><a href="#在-github-上创建新分支" class="headerlink" title="在 github 上创建新分支"></a>在 github 上创建新分支</h3><p>上个章节中展示了使用 master 分支来保存生成的博客页面的方法，但原来的markdown文件并没有保存。为了保存 Markdown 文件，在仓库中创建<code>source</code>分支。</p>
<img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/Snipaste_2022-03-20_17-58-33.png" style="zoom:75%"/>

<p>将source分支修改为默认分支：</p>
<img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/Snipaste_2022-03-20_18-06-26.png" style="zoom:75%"/>

<p>检查仓库的默认分支：</p>
<img src="https://cdn.jsdelivr.net/gh/xiaorangood/myImage/images/Snipaste_2022-03-20_18-07-14.png" style="zoom:75%"/>

<h3 id="设置本地仓库"><a href="#设置本地仓库" class="headerlink" title="设置本地仓库"></a>设置本地仓库</h3><p>在 blog 所在目录，执行仓库初始化，并设置远端仓库的地址。然后切换到目标分支。这里我的博客是在<code>D:/blog/</code>目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:xiaorangood/xiaorangood.github.io.git</span><br><span class="line">git checkout <span class="built_in">source</span> --</span><br></pre></td></tr></table></figure>
<p>因为我们只需要保留博客源码，其他无关的文件并不希望推送，需要确保配好了.gitignore文件，通常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">_multiconfig.yml</span><br></pre></td></tr></table></figure>

<h3 id="提交源文件"><a href="#提交源文件" class="headerlink" title="提交源文件"></a>提交源文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add . &amp;&amp;  git commit -m <span class="string">&quot;Regular save&quot;</span> &amp;&amp; git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<h3 id="删除非源文件"><a href="#删除非源文件" class="headerlink" title="删除非源文件"></a>删除非源文件</h3><p>由于source分支是从master复制而来，所以有一些是deployment文件。这些部署的文件可以删除，也可以理会。<br>删除文件夹后只剩下如下的文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node_modules/  scaffolds/  <span class="built_in">source</span>/  themes/</span><br></pre></td></tr></table></figure>

<h2 id="新环境"><a href="#新环境" class="headerlink" title="新环境"></a>新环境</h2><p>假设换电脑了，要在新环境继续在原有仓库基础上撸文章，此时通过git clone将博客源码拉到本地，然后安装、初始化hexo就能搞定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xiaorangood/xiaorangood.github.io.git blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install hexo</span><br><span class="line">npm install hexo-deployer-git -save</span><br><span class="line"></span><br><span class="line">// hexo环境配置好后，继续像之前一样</span><br><span class="line">hexo new post_name</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>静态博客</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列笔记-概述</title>
    <url>/2021/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="1-程序的本质"><a href="#1-程序的本质" class="headerlink" title="1 程序的本质"></a>1 程序的本质</h2><p>程序等于算法加数据结构。</p>
<h2 id="2-基本数据结构"><a href="#2-基本数据结构" class="headerlink" title="2 基本数据结构"></a>2 基本数据结构</h2><ol>
<li>线性结构:（1）线性表、（2）栈和队列、（3） 串、（4）数组和广义表</li>
<li>非线性结构：树、广义表</li>
</ol>
<h2 id="3-基本数据处理技术"><a href="#3-基本数据处理技术" class="headerlink" title="3 基本数据处理技术"></a>3 基本数据处理技术</h2><ol>
<li>查找技术</li>
<li>排序技术</li>
</ol>
<span id="more"></span>
<h2 id="4-数据结构的研究内容"><a href="#4-数据结构的研究内容" class="headerlink" title="4 数据结构的研究内容"></a>4 数据结构的研究内容</h2><h3 id="4-1-计算机解决问题的基本步骤"><a href="#4-1-计算机解决问题的基本步骤" class="headerlink" title="4.1 计算机解决问题的基本步骤"></a>4.1 计算机解决问题的基本步骤</h3><ol>
<li>具体问题抽象为数据模型，其实质为<ol>
<li>分析问题；</li>
<li>提取操作对象；</li>
<li>找出操作对象之间的关系；</li>
<li>用数学语言描述，即数据结构；</li>
</ol>
</li>
<li>设计算法</li>
<li>编程、调试、运行</li>
</ol>
<h3 id="4-2-计算机的应用"><a href="#4-2-计算机的应用" class="headerlink" title="4.2 计算机的应用"></a>4.2 计算机的应用</h3><p>早期，计算机主要应用于数值计算，例如求解梁架结构中的应力、预报人口增长情况。</p>
<p>数值计算的特点是数据元素之间的关系简单，但计算复杂。</p>
<p>现在，计算机越来越多地被用于非数值计算问题，例如学生学籍管理系统、图书管理系统、人事管理系统、仓库管理系统、通讯录等。</p>
<p>非数值计算各要素的含义</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>操作对象</th>
<th>操作算法</th>
<th>操作对象间关系</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>学籍管理系统中的关系</td>
<td>每位学生的信息</td>
<td>查询、插入、修改、删除等</td>
<td>线性关系</td>
<td>线性数据结构、线性表</td>
</tr>
<tr>
<td>人机棋局对弈问题中的关系</td>
<td>描述棋盘格局信息的棋局状态</td>
<td>走棋，即选择一种策略使棋局状态发生变化</td>
<td>非线性关系</td>
<td>树</td>
</tr>
</tbody></table>
<p>非数值计算问题的特点：</p>
<ol>
<li>所有问题无法使用数学公式或方程来描述，是一些“非数值计算”的程序设计问题；</li>
<li>描述非数值计算问题的数学模型不是数学方程，而是诸如表、树和图之类的具有逻辑关系的数据；</li>
<li>数据结构是一门研究非数值计算程序设计中操作对象以及它们之间的关系和操作的学科。</li>
</ol>
<h2 id="5-基本概念和术语"><a href="#5-基本概念和术语" class="headerlink" title="5 基本概念和术语"></a>5 基本概念和术语</h2><h3 id="5-1-数据（Data）"><a href="#5-1-数据（Data）" class="headerlink" title="5.1 数据（Data）"></a>5.1 数据（Data）</h3><p>数据（Data）是输入计算机且能被计算机处理的各种符号的集合，是信息的载体，是对客观事物符号化的表示；是能够被计算机识别、存储和加工。</p>
<p>数据包括数值型的数据和非数值型的数据；数值型的数据有整数、实数等；非数值型数据有文字、图像、图形、声音等。</p>
<h3 id="5-2-数据元素（Data-element）"><a href="#5-2-数据元素（Data-element）" class="headerlink" title="5.2 数据元素（Data element）"></a>5.2 数据元素（Data element）</h3><p>数据元素（Data element）是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。数据元素也简称为元素、记录、结点或顶点。例如学生表中一个学生的信息，即一个记录。</p>
<h3 id="5-3-数据项（Data-Item）"><a href="#5-3-数据项（Data-Item）" class="headerlink" title="5.3 数据项（Data Item）"></a>5.3 数据项（Data Item）</h3><p>数据项（Data Item）是构成数据元素的不分割的最小单位。例如学生表中一个学生的姓名、学号、性别、出生日期、政治面貌均可作为一个数据项。</p>
<h3 id="5-4-数据、数据元素、数据项三者之间的关系"><a href="#5-4-数据、数据元素、数据项三者之间的关系" class="headerlink" title="5.4 数据、数据元素、数据项三者之间的关系"></a>5.4 数据、数据元素、数据项三者之间的关系</h3><p>数据&gt;数据元素&gt;数据项。</p>
<h3 id="5-5-数据对象（Data-Object）"><a href="#5-5-数据对象（Data-Object）" class="headerlink" title="5.5 数据对象（Data Object）"></a>5.5 数据对象（Data Object）</h3><p>数据对象（Data Object）是性质相同的数据类型的集合，是数据的一个子集。例如整数数据对象、字母字符数据对象、学籍表也可以看作一个数据对象。</p>
<h3 id="5-6-数据元素与数据对象的区别"><a href="#5-6-数据元素与数据对象的区别" class="headerlink" title="5.6 数据元素与数据对象的区别"></a>5.6 数据元素与数据对象的区别</h3><ol>
<li>数据元素是组成数据的基本单位，是数据集合的个体；</li>
<li>数据对象是性质想吐的数据元素的集合，是数据集合的子集。</li>
</ol>
<h3 id="5-6-数据结构"><a href="#5-6-数据结构" class="headerlink" title="5.6 数据结构"></a>5.6 数据结构</h3><h4 id="5-6-1-定义"><a href="#5-6-1-定义" class="headerlink" title="5.6.1 定义"></a>5.6.1 定义</h4><p>数据元素不是孤立存在的，它们之间存在某种关系，数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素集合。数据结构是带结构的数据元素的集合。</p>
<h4 id="5-6-2-数据结构的内容"><a href="#5-6-2-数据结构的内容" class="headerlink" title="5.6.2 数据结构的内容"></a>5.6.2 数据结构的内容</h4><ul>
<li>数据元素之间的逻辑关系，也称为逻辑结构；</li>
<li>数据元素及其结构在计算机内存中的表示（又称为映像），称为数据的物理结果或数据的存储结构；</li>
<li>数据的运算和实现，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</li>
</ul>
<h4 id="5-6-3-数据结构的层次"><a href="#5-6-3-数据结构的层次" class="headerlink" title="5.6.3 数据结构的层次"></a>5.6.3 数据结构的层次</h4><p>数据结构的层次包括逻辑结构和存储结构。</p>
<ol>
<li>逻辑结构是描述数据元素之间的逻辑关系；与数据存储无关，独立于计算机；是从具体问题抽象出来的数学模型。</li>
<li>存储结构又称为物理结构，是数据元素及其关系在计算机存储器中的结构（存储方式）；是数据结构在计算机中的表示。</li>
<li>两者的关系：<ol>
<li>存储结构是逻辑关系的映射与元素本身的映像；</li>
<li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现；</li>
<li>两者综合起来建立了数据元素之间的结构关系。</li>
</ol>
</li>
</ol>
<h4 id="5-6-4-逻辑结构的分类"><a href="#5-6-4-逻辑结构的分类" class="headerlink" title="5.6.4 逻辑结构的分类"></a>5.6.4 逻辑结构的分类</h4><ol>
<li>划分方法一：线性结构和非线性结构。<ol>
<li>线性结构是有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。</li>
<li>非线性结构是一个节点可能有多个直接前驱和直接后继，例如树、图。</li>
</ol>
</li>
<li>划分方法二：将逻辑结构分为四种基本逻辑结构，即集合、线性、树、图。</li>
</ol>
<h4 id="5-6-5-存储结构的分类"><a href="#5-6-5-存储结构的分类" class="headerlink" title="5.6.5 存储结构的分类"></a>5.6.5 存储结构的分类</h4><p>存储结构的分类包括顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p>
<ol>
<li>顺序存储结构是用一组连续的存储单元，依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。C语言中用数组来实现顺序存储结构。</li>
<li>链式存储结构是用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。C语言中用指针来实现链式存储结构。</li>
<li>索引存储结构是在存储结点信息的同时，还建立附加的索引表。索引表的每一项称为索引项。索引表的一般形式是“(关键字，地址)”。关键字是能唯一表示结点的那些数据项。若每个结点的索引表中都有一个索引项，则该索引表称为稠密索引（Dense Index）。若一组结点子啊索引表中只对应一个索引项，则该索引表称为稀疏索引表（Sparse Index）。</li>
<li>散列存储结构是根据结点的关键字直接计算出该点的存储地址。</li>
</ol>
<h3 id="5-7-数据结构类型"><a href="#5-7-数据结构类型" class="headerlink" title="5.7 数据结构类型"></a>5.7 数据结构类型</h3><p>数据结构类型可以约束变量或常量的取值范围；约束变量或常量的操作。</p>
<p>数据类型（Data Type）是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。数据类型&#x3D;值的集合+值集合上的一组操作。</p>
<p>抽象数据类型（Abstract Data Type，ADT）是指一个数学模型以及定义在此数据模型上的一组操作。由用户定义，从问题抽象出数据模型（逻辑结构），还包括定义在数据模型上的一组抽象运算（相关操作），不考虑计算机内的具体存储结构与运损的具体实现算法。</p>
<p>抽象数据类型的形式定义：抽象数据类型可用（D，S，P）三元组表示，其中D是数据对象，S是D上的关系集，P是对D的基本操作集。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列笔记-算法与复杂度分析</title>
    <url>/2021/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="数据结构与算法的研究内容"><a href="#数据结构与算法的研究内容" class="headerlink" title="数据结构与算法的研究内容"></a>数据结构与算法的研究内容</h2><ol>
<li>逻辑结构：研究对象的特征及其相互之间的关系。</li>
<li>存储结构：研究有效组织计算机存储。</li>
<li>算法：有效地实现对象之间的“运算”关系。</li>
</ol>
<h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><p>算法是对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p>
<span id="more"></span>

<h2 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h2><ol>
<li>自然语言：英语、中文。</li>
<li>流程图：传统流程图、NS流程图。</li>
<li>伪代码（类语言）：类C语言。</li>
<li>程序代码：C语言程序、JAVA语言程序。</li>
</ol>
<h2 id="算法与程序的关系"><a href="#算法与程序的关系" class="headerlink" title="算法与程序的关系"></a>算法与程序的关系</h2><p>算法是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法。程序是用某种程序设计语言对算法的具体实现。程序&#x3D;数据结构+算法；数据结构通过算法实现操作；算法根据数据结构设计程序。</p>
<h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p>一个算法必须具备以下五个重要特征：</p>
<ol>
<li>有穷性：一个算法必须总是在执行有穷步骤之后结束，且每一步都在有穷时间内完成。</li>
<li>确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条直线路径，即对于相同的输入只能得到相同的输出。</li>
<li>可行性：算法是可以执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li>
<li>一个算法有零个或多个输入。</li>
<li>一个算法有一个或多个输出。</li>
</ol>
<h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><p>具有四个要求：</p>
<ol>
<li>正确性（Correctness）</li>
<li>可读性（Readability）</li>
<li>健壮性（Robustness）</li>
<li>高效性（Efficiency）</li>
</ol>
<h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>正确性是满足问题要求，能正确解决问题。<br>算法转换为程序后要注意：</p>
<ol>
<li>程序中不含语法错误；</li>
<li>程序对于几组输入数据能够得出满足要求的结果；</li>
<li>程序对于精心选择的、典型的、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果；</li>
<li>程序对于一切合法的输入数据都能得出满足要求的结果。</li>
</ol>
<p>通常以第三层意义上的正确性作为衡量一个算法是否合格的标准。</p>
<h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>可读性具有2层含义：</p>
<ol>
<li>算法主要是为了人阅读和交流，其次才是为计算机执行，因此算法应该易于人的理解；</li>
<li>另一方面，晦涩难读的算法易于隐藏较多错误而难以调试。</li>
</ol>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>健壮性是指当输入非法数据时，算法恰当的做出反应或进行相应处理，而不是产生莫名奇妙的输出结果。处理出错的方法，不应是中断程序的执行，而应该是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</p>
<h3 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h3><p>高效性要求尽量少的时间和尽量低的存储需求。</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>算法分析用来评价同一个问题的多个算法。算法分析的目的是看算法实际是否可行，并在同一问题存在多个算法时可进行性能上的比较，以便从中挑选除比较优的算法。</p>
<p>一个好算法首先具备正确性，然后健壮性、可读性；在这几个方面多满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。算法效率包括：</p>
<ol>
<li>时间效率：指算法所消耗的时间；</li>
<li>空间效率：指算法执行过程中所消耗的存储空间。</li>
</ol>
<p><strong>时间效率和空间效率有时候时矛盾的。</strong></p>
<h2 id="算法的时间效率"><a href="#算法的时间效率" class="headerlink" title="算法的时间效率"></a>算法的时间效率</h2><p>算法时间效率可以用依据该算法编制的程序在计算机上所消耗的时间来度量。有两种<strong>度量</strong>方法：</p>
<ol>
<li>事后统计：将算法实现，测孙其时间和空间开销；缺点是编写程序实现算法将或非较多的时间和精力，所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。</li>
<li>事前分析：对算法所消耗资源的一种估计算法。</li>
</ol>
<h3 id="事前分析法"><a href="#事前分析法" class="headerlink" title="事前分析法"></a>事前分析法</h3><ul>
<li>一个算法的运行时间是一个算法在计算机上运行所耗费的时间，大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的<strong>时间</strong>与算法中进行的简单操作<strong>次数乘积</strong>。<ul>
<li>算法运行时间 &#x3D; 一个简单操作所需要的时间×简单操作次数。</li>
</ul>
</li>
<li>即算法中每条语句的执行时间之和。<ul>
<li>算法运行时间 &#x3D; Σ(每条语句执行次数)×该语句执行一次所需要的时间。</li>
<li>每条语句的执行次数又称为语句的频度。</li>
<li>算法运行时间 &#x3D; Σ(每条语句频度)×该语句执行一次所需要的时间。</li>
</ul>
</li>
<li>每条语句执行一次所需的时间，一般都是随机器而异的。每条语句执行一次所需的时间，一般都是随机器而异的。取决于机器的指令性能、速度以及编译的代码质量，是由机器本身软硬件环境决定的，它与算法无关。</li>
<li>我们可<strong>以假设执行每条语句所需的时间均为单位时间</strong>，此时对算法运行时间的讨论就可以转化为讨论该算法中所有语句的执行次数，即<strong>频度之和</strong>了。</li>
<li>这就可以独立于不同机器的软硬件环境来分析算法的时间性能了。</li>
</ul>
<p>算法运行时间的例子：两个n×n矩阵相乘算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)                            <span class="comment">// n+1次，n次循环，1次判断</span></span><br><span class="line">   <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=n; j++) &#123;                       <span class="comment">// n*(n+1)次，外层循环n次，内层n+1次</span></span><br><span class="line">      c[i][j] = <span class="number">0</span>;                              <span class="comment">// n*n次，2层循环</span></span><br><span class="line">      <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)                       <span class="comment">// n*n*(n+1)次，外面2层循环，内层n+1次</span></span><br><span class="line">      c[i][j] = c[i][j] + a[i][k] * b[k][j];    <span class="comment">// n*n*n次，三层循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把算法所耗费的时间定义为该算法中<strong>每条语句的频度之和</strong>，则该算法的时间消耗T(n)为：T(n) &#x3D; 2×n3 + 3×n2 + 2×n + 1。</p>
<h3 id="数量级"><a href="#数量级" class="headerlink" title="数量级"></a>数量级</h3><p>为了便于不同算法的时间效率，我们仅比较它们的数量级。例如，$T_1(n) &#x3D; 10 \times n^2$ 与 $T_2(n)&#x3D;5 \times n$这两个比较。若有某个辅助函数f(n)使得当n趋近于无穷大时，$T(n)&#x2F;f(n)$的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作$T(n)&#x3D;O(f(n))$，称$O(f(n))$为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度。</p>
<p>例如，公式$T(n) &#x3D; 2 \times n^3 + 3 \times n^2 + 2 \times n + 1$中，当$n\rightarrow \infin$时，$T(n)&#x2F;n^2 \rightarrow 2$，这表示$n$充分大时，$T(n)$与$n^3$是同阶或同数量级，引入大“O”记号，则$T(n)$可记作：$T(n)&#x3D;O(n^3)$</p>
<h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><ul>
<li>定义：算法中基本语句重复执行的次数是问题规模$n$的某个函数$f(n)$，算法的时间量度记作：$T(n)&#x3D;O(n)$。它表示随着n的增大，算法执行的时间的增长率和$f(n)$的增长率相同，称为渐进时间复杂度。数据符号“O”定义为若$T(n)$和$f(n)$是定义在正整数集合上的两个函数，则$T(n)&#x3D;O(f(n))$表示存在正的常数$C$和$n_0$，使得当$n≥n_0$时都满足$0≤T(n)≤C*f(n)$。</li>
<li>基本语句是指算法中重复执行次数和算法的执行时间成正比的语句；对算法运行时间的贡献最大的语句；执行次数最多语句。</li>
<li>问题规模$n$越大，算法的执行时间越长。对于排序来说，$n$为记录数；对于矩阵来说，$n$为矩阵的阶数；对于多项式来说，$n$为多项式的项数；对于集合来说，$n$为元素个数；对于树来说，$n$为树的结点个数；对于图来说，$n$为图的顶点数或边数。</li>
</ul>
<h3 id="分析算法时间复杂度的基本方法"><a href="#分析算法时间复杂度的基本方法" class="headerlink" title="分析算法时间复杂度的基本方法"></a>分析算法时间复杂度的基本方法</h3><ul>
<li>一般方法：<ul>
<li>找出语句频度最大的那条语句作为基本语句;</li>
<li>计算基本语句的频度得到问题规模n的某个函数f(n)；</li>
<li>取其数量级用符号“O”表示。</li>
</ul>
</li>
<li>技巧:<ul>
<li>忽略所有低次幂项和高次幂系数，体现增长率的含义；</li>
<li>时间复杂度是由嵌套最深语句的频度决定的。</li>
</ul>
</li>
</ul>
<h3 id="时间复杂度分析例题"><a href="#时间复杂度分析例题" class="headerlink" title="时间复杂度分析例题"></a>时间复杂度分析例题</h3><p>计算下方语句的时间复杂度。</p>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">1</span>; j&lt;=j; j++)</span><br><span class="line">            x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>$$<br>语句的频度&#x3D; \sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\sum_{z&#x3D;1}^n &#x3D; \sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^nj &#x3D; \sum_{i&#x3D;1}^n \frac{i(i+1)}{2}&#x3D;\frac{1}{2} \left( \sum_{i&#x3D;1}^ni^2+ \sum_{i&#x3D;1}^ni\right) \<br>&#x3D;frac{1}{2} \left( \frac{n(n+1)(n+2)}{6} + \frac{n(n+1)}{2}\right) &#x3D; \frac{n(n+1)(n+2)}{6}\</p>
<p>$$</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
